---
layout:     post   				    # 使用的布局（不需要改）
title:      力扣之数组			# 标题 
subtitle:    #副标题
date:       2023-05-01 				# 时间
author:     By xrj						# 作者
header-img: img/post-bg-2015.jpg 	#这篇文章标题背景图片
catalog: true 						# 是否归档
tags:								#标签
    - 算法
    - 数组
    - 力扣
---

标号是力扣的题号，并非题目序列号

## 1. 两数之和

1. 暴力循环

    两个for循环将两数相加，找到target

2. hash

    每读一个数，遍历hash表，如果相加等于target就输出；遍历完hash表后意味着没有匹配的值，就将该数也加入到hash表中

    这里用到stl的一个类``unorder_map``，无序关联容器，可以用python的字典来理解它的用法。``map.find(key)``可以根据键来查找对应的值。

## 2. 两数相加

1. 正常模拟

    唯一要注意的点在于，计算到最后一位会产生进位，要判断是否需要添加节点存储进位。

## 4.寻找两个数组的中位数

1. 合并后排序

    ```C++
    vector<int> nums;
    nums.sort();
    ```

2. 二分查找

    方法一用了现成的轮子，复杂度上也不满足，二分的复杂度为log(m+n)

## 15. 三数之和

1. 排序+双指针

    本题难点在于如何去除重复解，以及当有重复解时，一一枚举耗费时间太长，比如[0,0,0,0,0,0]

    可以考虑排序后，left和right同时缩进，如果>0，说明right太大，right左移；如果<0,说明left太小，left右移。如果缩进后，值和原本的值一样，就继续缩进

    ```C++
    for(first){
        if(nums[first]==nums[first+1]) continue;
        for(second = first+1){
            if (nums[second]=nums[second+1]) continue;

            while(second<third && nums[second]+nums[third]+nums[first]>0){
                right-- ;
            }

            if(left==right) break;
            if(nums[first]+nums[second]+nums[third] = 0) 
            results.push_back({nums[first],nums[second],nums[third]});
        }
    }
    ```
